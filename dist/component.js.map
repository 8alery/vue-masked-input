{"version":3,"sources":["webpack:///component.js","webpack:///webpack/bootstrap 47a8ae8809f0d5b186bd?698a","webpack:///./src/ff-polyfill.js?7c2c","webpack:///./~/inputmask-core/lib/index.js?3294","webpack:///./src/MaskedInput.js?cf87"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","59","__webpack_exports__","addPolyfill","e","type","event","CustomEvent","bubbles","cancelable","c1Generated","target","dispatchEvent","removePolyfill","removeEventListener","setTimeout","w","window","document","undefined","onfocusin","addEventListener","60","extend","dest","src","props","keys","length","copy","obj","mergeFormatCharacters","formatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","Pattern","source","placeholderChar","isRevealingMask","this","DEFAULT_PLACEHOLDER_CHAR","pattern","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","options","selection","start","end","Error","setPattern","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","*","validate","test","1","a","A","transform","toUpperCase","#","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","input","selectionBefore","valueBefore","getValue","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","backspace","paste","initialState","slice","charAt","substring","valid","undo","historyItem","startUndo","redo","pop","setValue","emptyValue","join","_resetHistory","setSelection","getRawValue","rawValue","88","__WEBPACK_IMPORTED_MODULE_0_inputmask_core__","__WEBPACK_IMPORTED_MODULE_0_inputmask_core___default","__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__","template","data","marginLeft","mask_core","updateAfterAll","String","mask","required","validator","default","disabled","Boolean","watch","newMask","initMask","newValue","mounted","methods","+","$refs","$emit","updateToCoreState","console","error","message","keyDown","preventDefault","setNativeSelection","keyCode","selectionStart","selectionEnd","keyPress","ctrlKey","isIE","documentMode","isFirefox","InstallTrigger","key","textInput","keyUp","cut","execCommand","err","text","clipboardData","getData","focusin","isEmpty","focusout","mouseUp"],"mappings":"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","file":"component.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 88);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 59:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\n/* harmony default export */ __webpack_exports__[\"a\"] = function () {\n  var w = window,\n      d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) {\n      // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n};;\n\n/***/ }),\n\n/***/ 60:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n/***/ }),\n\n/***/ 88:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inputmask_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__ = __webpack_require__(59);\n\n //Firefox Polyfill for focus events\n__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__[\"a\" /* default */])();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = {\n\n  template: '\\n    <input ref=\"input\"\\n      :value=\"value\"\\n      @keydown=\"keyDown(arguments[0])\"\\n      @keypress=\"keyPress(arguments[0])\"\\n      @keyup=\"keyUp(arguments[0])\"\\n      @textInput=\"textInput(arguments[0])\"\\n      @mouseup=\"mouseUp(arguments[0])\"\\n      @focus.prevent=\"focusin(arguments[0])\"\\n      @focusout=\"focusout(arguments[0])\"\\n      @cut=\"cut(arguments[0])\"\\n      @copy=\"copy(arguments[0])\"\\n      @paste=\"paste(arguments[0])\"\\n      :disabled=\"mask_core===null || disabled\"\\n    />\\n  ',\n\n  name: 'MaskedInput',\n\n  data: function data() {\n    return {\n      marginLeft: 0,\n      mask_core: null,\n      updateAfterAll: false\n    };\n  },\n\n  props: {\n    value: {\n      type: String\n    },\n    mask: {\n      type: String,\n      required: true,\n      validator: function validator(value) {\n        return !!(value && value.length >= 1);\n      }\n    },\n    placeholderChar: {\n      type: String,\n      default: '_',\n      validator: function validator(value) {\n        return !!(value && value.length === 1);\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  watch: {\n    mask: function mask(newMask) {\n      this.initMask();\n    },\n    value: function value(newValue) {\n      if (this.mask_core) this.mask_core.setValue(newValue); //For multiple inputs support\n    }\n  },\n\n  mounted: function mounted() {\n    this.initMask();\n  },\n\n\n  methods: {\n    initMask: function initMask() {\n      try {\n        this.mask_core = new __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default.a({\n          pattern: this.mask,\n          value: '',\n          placeholderChar: this.placeholderChar,\n          formatCharacters: {\n            'a': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            'A': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '*': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            '#': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '+': {\n              validate: function validate(char) {\n                return true;\n              }\n            }\n          }\n        });\n        for (var i = 0; i < this.$refs.input.value.length; ++i) {\n          this.mask_core.input(this.$refs.input.value[i]);\n        }\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        if (this.$refs.input.value === '') {\n          this.$emit('input', '', '');\n        } else {\n          this.updateToCoreState();\n        }\n      } catch (e) {\n        console.error(e.message);\n        this.mask_core = null;\n        this.$refs.input.value = 'Error, see console';\n        this.$emit('input', this.$refs.input.value, '');\n      }\n    },\n    getValue: function getValue() {\n      if (this.mask_core === null) return '';\n      return this.mask_core.getValue();\n    },\n    keyDown: function keyDown(e) {\n      //Always\n      if (this.mask_core === null) {\n        e.preventDefault();\n        return;\n      }\n      this.setNativeSelection();\n\n      switch (e.keyCode) {\n\n        //backspace\n        case 8:\n          e.preventDefault();\n          if (this.mask_core.selection.start > this.marginLeft || this.mask_core.selection.start != this.mask_core.selection.end) {\n            this.mask_core.backspace();\n            this.updateToCoreState();\n          }\n          break;\n\n        //left arrow\n        case 37:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd = this.$refs.input.selectionStart--;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //right arrow\n        case 39:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd++;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //end\n        case 35:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //home\n        case 36:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0;\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //delete\n        case 46:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n            this.mask_core.setValue('');\n            this.mask_core.setSelection({\n              start: 0,\n              end: 0\n            });\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\n          } else {\n            this.mask_core.backspace();\n          }\n          this.updateToCoreState();\n          break;\n      }\n    },\n    input: function input(e) {},\n    keyPress: function keyPress(e) {\n      //works only on Desktop\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\n      /*\r\n       IE & FF are not trigger textInput event, so we have to force it\r\n      */\n      var isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      var isFirefox = typeof InstallTrigger !== 'undefined';\n\n      if (isIE || isFirefox) {\n        e.preventDefault();\n        e.data = e.key;\n        this.textInput(e);\n      }\n    },\n    textInput: function textInput(e) {\n      if (e.preventDefault) e.preventDefault();\n      if (this.mask_core.input(e.data)) {\n        this.updateAfterAll = true;\n      }\n      this.updateToCoreState();\n    },\n    keyUp: function keyUp(e) {\n      this.updateToCoreState();\n      this.updateAfterAll = false;\n    },\n    cut: function cut(e) {\n      e.preventDefault();\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\n        /*let text = this.$refs.input.value.slice(\r\n          this.$refs.input.selectionStart,\r\n          this.$refs.input.selectionEnd\r\n        )*/\n        try {\n          document.execCommand('copy');\n        } catch (err) {}\n        this.mask_core.backspace();\n        this.updateToCoreState();\n      }\n    },\n    copy: function copy(e) {},\n    paste: function paste(e) {\n      e.preventDefault();\n      var text = e.clipboardData.getData('text');\n      for (var i = 0; i < text.length; ++i) {\n        this.mask_core.input(text[i]);\n      }\n      this.updateToCoreState();\n    },\n    updateToCoreState: function updateToCoreState() {\n      if (this.mask_core === null) {\n        return;\n      }\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\n        this.$refs.input.value = this.mask_core.getValue();\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue());\n      }\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\n    },\n    focusin: function focusin(e) {},\n    isEmpty: function isEmpty() {\n      if (this.mask_core === null) return true;\n      return this.mask_core.getValue() === this.mask_core.emptyValue;\n    },\n    focusout: function focusout(e) {\n      if (this.isEmpty()) {\n        this.$refs.input.value = '';\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$emit('input', '', '');\n      }\n    },\n    setNativeSelection: function setNativeSelection() {\n      this.mask_core.selection = {\n        start: this.$refs.input.selectionStart,\n        end: this.$refs.input.selectionEnd\n      };\n    },\n    mouseUp: function mouseUp(e) {\n      if (this.isEmpty() && this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\n        this.marginLeft = this.mask_core.selection.start;\n        this.updateToCoreState();\n      } else {\n        this.setNativeSelection();\n      }\n    }\n  }\n\n};\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// component.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 88);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 47a8ae8809f0d5b186bd","//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\nexport default function() {\n  var w = window,\n    d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) { // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ff-polyfill.js","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask-core/lib/index.js\n// module id = 60\n// module chunks = 0 1","import InputMask from 'inputmask-core'\r\nimport ffpoly from './ff-polyfill.js' //Firefox Polyfill for focus events\r\nffpoly()\r\n\r\nexport default {\r\n\r\n  template: `\r\n    <input ref=\"input\"\r\n      :value=\"value\"\r\n      @keydown=\"keyDown(arguments[0])\"\r\n      @keypress=\"keyPress(arguments[0])\"\r\n      @keyup=\"keyUp(arguments[0])\"\r\n      @textInput=\"textInput(arguments[0])\"\r\n      @mouseup=\"mouseUp(arguments[0])\"\r\n      @focus.prevent=\"focusin(arguments[0])\"\r\n      @focusout=\"focusout(arguments[0])\"\r\n      @cut=\"cut(arguments[0])\"\r\n      @copy=\"copy(arguments[0])\"\r\n      @paste=\"paste(arguments[0])\"\r\n      :disabled=\"mask_core===null || disabled\"\r\n    />\r\n  `,\r\n\r\n  name: 'MaskedInput',\r\n\r\n  data: () => ({\r\n    marginLeft: 0,\r\n    mask_core: null,\r\n    updateAfterAll: false\r\n  }),\r\n\r\n  props: {\r\n    value: {\r\n      type: String\r\n    },\r\n    mask: {\r\n      type: String,\r\n      required: true,\r\n      validator:  value => !! (value && value.length >= 1)\r\n    },\r\n    placeholderChar: {\r\n      type: String,\r\n      default: '_',\r\n      validator:  value => !! (value && value.length === 1)\r\n    },\r\n    disabled: {\r\n      type: Boolean,\r\n      default: false\r\n    }\r\n  },\r\n\r\n  watch: {\r\n    mask: function(newMask) {\r\n      this.initMask()\r\n    },\r\n    value: function(newValue) {\r\n      if (this.mask_core) this.mask_core.setValue(newValue) //For multiple inputs support\r\n    },\r\n  },\r\n\r\n  mounted() {\r\n    this.initMask()\r\n  },\r\n\r\n  methods: {\r\n\r\n    initMask() {\r\n      try {\r\n        this.mask_core = new InputMask({\r\n          pattern: this.mask,\r\n          value: '',\r\n          placeholderChar: this.placeholderChar,\r\n          formatCharacters: {\r\n            'a': {\r\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char),\r\n            },\r\n            'A': {\r\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char) ,\r\n              transform: char => char.toUpperCase()\r\n            },\r\n            '*': {\r\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\r\n            },\r\n            '#': {\r\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\r\n              transform: char => char.toUpperCase()\r\n            },\r\n            '+': {\r\n              validate: char => true,\r\n            },\r\n          }\r\n        })\r\n        for (let i = 0; i < this.$refs.input.value.length; ++i) {\r\n          this.mask_core.input(this.$refs.input.value[i])\r\n        }\r\n        this.mask_core.setSelection({\r\n          start: 0,\r\n          end: 0\r\n        })\r\n        if (this.$refs.input.value === '') {\r\n          this.$emit('input', '', '')\r\n        }\r\n        else {\r\n          this.updateToCoreState()\r\n        }\r\n\r\n\r\n      }\r\n      catch (e) {\r\n        console.error(e.message);\r\n        this.mask_core = null\r\n        this.$refs.input.value = 'Error, see console'\r\n        this.$emit('input', this.$refs.input.value, '')\r\n      }\r\n    },\r\n\r\n    getValue() {\r\n      if (this.mask_core === null) return '';\r\n      return this.mask_core.getValue()\r\n    },\r\n\r\n    keyDown(e) { //Always\r\n      if (this.mask_core === null) {\r\n        e.preventDefault()\r\n        return;\r\n      }\r\n      this.setNativeSelection()\r\n\r\n\r\n      switch (e.keyCode) {\r\n\r\n        //backspace\r\n        case 8:\r\n          e.preventDefault()\r\n          if (\r\n            this.mask_core.selection.start > this.marginLeft ||\r\n            this.mask_core.selection.start != this.mask_core.selection.end\r\n          ) {\r\n            this.mask_core.backspace()\r\n            this.updateToCoreState()\r\n          }\r\n          break;\r\n\r\n        //left arrow\r\n        case 37:\r\n          e.preventDefault()\r\n\r\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\r\n            this.$refs.input.selectionEnd = this.$refs.input.selectionStart--\r\n\r\n            this.mask_core.selection = {\r\n              start: this.$refs.input.selectionStart,\r\n              end: this.$refs.input.selectionStart\r\n            }\r\n            this.updateToCoreState()\r\n          break;\r\n\r\n        //right arrow\r\n        case 39:\r\n          e.preventDefault()\r\n\r\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\r\n            this.$refs.input.selectionEnd++;\r\n\r\n          this.mask_core.selection = {\r\n            start: this.$refs.input.selectionEnd,\r\n            end: this.$refs.input.selectionEnd\r\n          }\r\n          this.updateToCoreState()\r\n          break;\r\n\r\n        //end\r\n        case 35:\r\n          e.preventDefault()\r\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length\r\n\r\n          this.mask_core.selection = {\r\n            start: this.$refs.input.selectionEnd,\r\n            end: this.$refs.input.selectionEnd\r\n          }\r\n          this.updateToCoreState()\r\n          break;\r\n\r\n        //home\r\n        case 36:\r\n          e.preventDefault()\r\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0\r\n          this.mask_core.selection = {\r\n            start: this.$refs.input.selectionStart,\r\n            end: this.$refs.input.selectionStart\r\n          }\r\n          this.updateToCoreState()\r\n          break;\r\n\r\n        //delete\r\n        case 46:\r\n          e.preventDefault()\r\n\r\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\r\n            this.mask_core.setValue('');\r\n            this.mask_core.setSelection({\r\n              start: 0,\r\n              end: 0\r\n            })\r\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\r\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\r\n\r\n          } else {\r\n            this.mask_core.backspace()\r\n          }\r\n          this.updateToCoreState()\r\n          break;\r\n      }\r\n    },\r\n\r\n    input(e) {\r\n    },\r\n\r\n    keyPress(e) { //works only on Desktop\r\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\r\n      /*\r\n       IE & FF are not trigger textInput event, so we have to force it\r\n      */\r\n      let isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\r\n      let isFirefox = typeof InstallTrigger !== 'undefined';\r\n\r\n\r\n      if (isIE || isFirefox) {\r\n        e.preventDefault()\r\n        e.data = e.key\r\n        this.textInput(e)\r\n      }\r\n    },\r\n\r\n    textInput(e) {\r\n      if (e.preventDefault) e.preventDefault()\r\n      if (this.mask_core.input(e.data)) {\r\n        this.updateAfterAll = true\r\n      }\r\n      this.updateToCoreState()\r\n    },\r\n\r\n    keyUp(e) {\r\n      this.updateToCoreState()\r\n      this.updateAfterAll = false\r\n    },\r\n\r\n\r\n    cut(e) {\r\n      e.preventDefault();\r\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\r\n        /*let text = this.$refs.input.value.slice(\r\n          this.$refs.input.selectionStart,\r\n          this.$refs.input.selectionEnd\r\n        )*/\r\n        try {\r\n          document.execCommand('copy')\r\n        } catch (err) {}\r\n        this.mask_core.backspace()\r\n        this.updateToCoreState()\r\n      }\r\n    },\r\n\r\n    copy(e) {\r\n    },\r\n\r\n    paste(e) {\r\n      e.preventDefault()\r\n      let text = e.clipboardData.getData('text')\r\n      for (let i = 0; i < text.length; ++i) {\r\n        this.mask_core.input(text[i])\r\n      }\r\n      this.updateToCoreState()\r\n    },\r\n\r\n    updateToCoreState() {\r\n      if (this.mask_core === null) {\r\n        return;\r\n      }\r\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\r\n        this.$refs.input.value = this.mask_core.getValue()\r\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue())\r\n      }\r\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\r\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\r\n    },\r\n\r\n    focusin(e) {\r\n    },\r\n\r\n    isEmpty() {\r\n      if (this.mask_core === null) return true;\r\n      return this.mask_core.getValue() === this.mask_core.emptyValue\r\n    },\r\n\r\n    focusout(e) {\r\n      if (this.isEmpty()) {\r\n        this.$refs.input.value = ''\r\n        this.mask_core.setSelection({\r\n          start: 0,\r\n          end: 0\r\n        })\r\n        this.$emit('input', '', '')\r\n      }\r\n    },\r\n\r\n    setNativeSelection() {\r\n      this.mask_core.selection = {\r\n        start: this.$refs.input.selectionStart,\r\n        end: this.$refs.input.selectionEnd\r\n      }\r\n    },\r\n\r\n    mouseUp(e) {\r\n      if (this.isEmpty() &&\r\n        this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\r\n        this.mask_core.setSelection({\r\n          start: 0,\r\n          end: 0\r\n        })\r\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\r\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\r\n        this.marginLeft = this.mask_core.selection.start;\r\n        this.updateToCoreState();\r\n      }\r\n      else {\r\n        this.setNativeSelection();\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/MaskedInput.js"],"sourceRoot":""}