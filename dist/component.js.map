{"version":3,"sources":["webpack:///component.js","webpack:///webpack/bootstrap 50f3647a6bdc53ba6aa4?a01f","webpack:///./~/vue-loader/lib/component-normalizer.js?d4f3","webpack:///MaskedInput.vue?9351","webpack:///./src/MaskedInput.vue?9a93*","webpack:///./src/ff-polyfill.js?7c2c","webpack:///./~/inputmask-core/lib/index.js?3294","webpack:///./src/MaskedInput.vue?88f9"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","48","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","type","default","options","render","staticRenderFns","_scopeId","computed","keys","forEach","key","60","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_inputmask_core__","__WEBPACK_IMPORTED_MODULE_0_inputmask_core___default","__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__","data","marginLeft","mask_core","updateAfterAll","props","String","mask","required","validator","length","placeholderChar","disabled","Boolean","watch","newMask","this","initMask","newValue","setValue","mounted","methods","a","pattern","formatCharacters","validate","char","test","A","transform","toUpperCase","*","#","+","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","$refs","input","Symbol","iterator","next","done","err","return","setSelection","start","end","$emit","updateToCoreState","e","console","error","getValue","keyDown","preventDefault","setNativeSelection","keyCode","selection","backspace","selectionStart","selectionEnd","keyPress","ctrlKey","isIE","document","documentMode","isFirefox","InstallTrigger","textInput","keyUp","cut","execCommand","copy","paste","pasteText","clipboardData","getData","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","getRawValue","focusin","isEmpty","emptyValue","focusout","mouseUp","61","_vm","_h","$createElement","_c","_self","ref","attrs","domProps","on","keydown","$event","arguments","keypress","keyup","mouseup","focus","62","addPolyfill","event","CustomEvent","bubbles","cancelable","c1Generated","target","dispatchEvent","removePolyfill","removeEventListener","setTimeout","w","window","onfocusin","addEventListener","89","extend","dest","src","obj","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","Pattern","source","isRevealingMask","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","Error","setPattern","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","1","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","valid","undo","historyItem","startUndo","redo","pop","join","_resetHistory","rawValue","91","Component"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,OAGA,IAAAC,GAAAF,EAAAD,IACAI,EAAAJ,EACAK,GAAA,EACAH,WAUA,OANAJ,GAAAE,GAAAM,KAAAH,EAAAD,QAAAC,IAAAD,QAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,QAvBA,GAAAD,KA+DA,OAnCAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAK,EAAA,SAAAK,GAA2C,MAAAA,IAG3CV,EAAAW,EAAA,SAAAR,EAAAS,EAAAC,GACAb,EAAAc,EAAAX,EAAAS,IACAG,OAAAC,eAAAb,EAAAS,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAb,EAAAoB,EAAA,SAAAhB,GACA,GAAAS,GAAAT,KAAAiB,WACA,WAA2B,MAAAjB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAJ,GAAAW,EAAAE,EAAA,IAAAA,GACAA,GAIAb,EAAAc,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDvB,EAAA0B,EAAA,SAGA1B,IAAA2B,EAAA,MDMMC,GACA,SAAUxB,EAAQD,GEvExBC,EAAAD,QAAA,SACA0B,EACAC,EACAC,EACAC,GAEA,GAAAC,GACAC,EAAAL,QAGAM,QAAAN,GAAAO,OACA,YAAAD,GAAA,aAAAA,IACAF,EAAAJ,EACAK,EAAAL,EAAAO,QAIA,IAAAC,GAAA,kBAAAH,GACAA,EAAAG,QACAH,CAcA,IAXAJ,IACAO,EAAAC,OAAAR,EAAAQ,OACAD,EAAAE,gBAAAT,EAAAS,iBAIAR,IACAM,EAAAG,SAAAT,GAIAC,EAAA,CACA,GAAAS,GAAAJ,EAAAI,WAAAJ,EAAAI,YACA1B,QAAA2B,KAAAV,GAAAW,QAAA,SAAAC,GACA,GAAAxC,GAAA4B,EAAAY,EACAH,GAAAG,GAAA,WAAmC,MAAAxC,MAInC,OACA6B,WACA9B,QAAA+B,EACAG,aFgFMQ,GACA,SAAUzC,EAAQ0C,EAAqB9C,GAE7C,YACAe,QAAOC,eAAe8B,EAAqB,cAAgBpC,OAAO,GAC7C,IAAIqC,GAA+C/C,EAAoB,IACnEgD,EAAuDhD,EAAoBoB,EAAE2B,GAC7EE,EAAgDjD,EAAoB,GG/G7FA,GAAAK,EAAA4C,EAAA,KAEAH,EAAA,SHsIElC,KGlIF,cHoIEsC,KAAM,WACJ,OACEC,WGpIN,EHqIMC,UGpIN,KHqIMC,gBGlIN,IHsIEC,OACE5C,OACEyB,KGpINoB,QHsIIC,MACErB,KGrINoB,OHsIME,UGrIN,EHsIMC,UAAW,SAAmBhD,GAC5B,SAAUA,GAASA,EAAMiD,QGrIjC,KHwIIC,iBACEzB,KGvINoB,OHwIMnB,QGvIN,IHwIMsB,UAAW,SAAmBhD,GAC5B,SAAUA,GGvIlB,IHuI2BA,EAAMiD,UAG7BE,UACE1B,KGzIN2B,QH0IM1B,SGtIN,IH0IE2B,OACEP,KAAM,SAAcQ,GAClBC,KGzINC,YH2IIxD,MAAO,SAAeyD,GAChBF,KAAKb,WAAWa,KAAKb,UAAUgB,SAASD,KAIhDE,QAAS,WACPJ,KGzIJC,YH6IEI,SACEJ,SAAU,WACR,IAEED,KAAKb,UAAY,GAAIJ,GAAqDuB,GACxEC,QAASP,KGzInBT,KH0IU9C,MGzIV,GH0IUkD,gBAAiBK,KGzI3BL,gBH0IUa,kBACEF,GACEG,SAAU,SAAkBC,GAC1B,MAAQ,mBAAmBC,KGzI3CD,KH6IYE,GACEH,SAAU,SAAkBC,GAC1B,MAAQ,mBAAmBC,KG7I3CD,IHgJcG,UAAW,SAAmBH,GAC5B,MAAOA,GG/IvBI,gBHkJYC,KACEN,SAAU,SAAkBC,GAC1B,MAAQ,qBAAqBC,KGjJ7CD,KHqJYM,KACEP,SAAU,SAAkBC,GAC1B,MAAQ,qBAAqBC,KGrJ7CD,IHwJcG,UAAW,SAAmBH,GAC5B,MAAOA,GGvJvBI,gBH0JYG,KACER,SAAU,SAAkBC,GAC1B,OGtJhB,MAzBA,IAAAQ,IAAA,EHsLYC,GAAoB,EACpBC,EAAiBC,MAErB,KACE,IAAK,GAA2DC,GAAvDC,EAAYvB,KAAKwB,MAAMC,MAAMhF,MAAMiF,OAAOC,cAAsBT,GAA6BI,EAAQC,EAAUK,QAAQC,MAAOX,GAA4B,EAAM,CGhKnL,GAAAR,GAAAY,EAAA7E,KHmKYuD,MAAKb,UAAUsC,MGlK3Bf,IHoKU,MAAOoB,GACPX,GAAoB,EACpBC,EAAiBU,EACjB,QACA,KACOZ,GAA6BK,EAAUQ,QAC1CR,EAAUQ,SAEZ,QACA,GAAIZ,EACF,KAAMC,IAKZpB,KAAKb,UAAU6C,cACbC,MGjLV,EHkLUC,IGhLV,IHkLuC,KAA3BlC,KAAKwB,MAAMC,MAAMhF,MACnBuD,KAAKmC,MAAM,QAAS,GGjL9B,IHmLUnC,KGhLVoC,oBAIA,MAAAC,GH+KQC,QAAQC,MG7KhBF,GH8KQrC,KAAKb,UG7Kb,KH8KQa,KAAKwB,MAAMC,MAAMhF,MG7KzB,qBH8KQuD,KAAKmC,MAAM,QAASnC,KAAKwB,MAAMC,MAAMhF,MG7K7C,MHgLI+F,SAAU,WACR,MAAuB,QAAnBxC,KAAKb,UG5Kf,GH6Kaa,KAAKb,UG5KlBqD,YH8KIC,QAAS,SAAiBJ,GAExB,GAAuB,OAAnBrC,KAAKb,UG1Kf,WH2KQkD,GG5KRK,gBHiLM,QAFA1C,KG1KN2C,qBH4KcN,EG1KdO,SH6KQ,IG3KR,GH4KUP,EG3KVK,kBACA1C,KAAAb,UAAA0D,UAAAZ,MAAAjC,KACAd,YAAAc,KAAAb,UAAA0D,UAAAZ,OAAAjC,KAAAb,UAAA0D,UACAX,OH0KYlC,KAAKb,UGxKjB2D,YHyKY9C,KGxKZoC,oBAGA,MH0KQ,KGxKR,IHyKUC,EGvKVK,iBHyKc1C,KAAKwB,MAAMC,MAAMsB,iBAAmB/C,KAAKwB,MAAMC,MGxK7DuB,eAAAhD,KAAAwB,MAAAC,MAAAuB,aAAAhD,KAAAwB,MAAAC,MAEAsB,kBHwKU/C,KAAKb,UAAU0D,WACbZ,MAAOjC,KAAKwB,MAAMC,MGvK9BsB,eHwKYb,IAAKlC,KAAKwB,MAAMC,MGtK5BsB,gBHwKU/C,KGvKVoC,mBAEA,MHyKQ,KGvKR,IHwKUC,EGtKVK,iBHwKc1C,KAAKwB,MAAMC,MAAMsB,iBAAmB/C,KAAKwB,MAAMC,MGvK7DuB,cAAAhD,KAAAwB,MAAAC,MAEAuB,eHuKUhD,KAAKb,UAAU0D,WACbZ,MAAOjC,KAAKwB,MAAMC,MGtK9BuB,aHuKYd,IAAKlC,KAAKwB,MAAMC,MGrK5BuB,cHuKUhD,KGtKVoC,mBAEA,MHwKQ,KGtKR,IHuKUC,EGtKVK,iBHuKU1C,KAAKwB,MAAMC,MAAMsB,eAAiB/C,KAAKwB,MAAMC,MAAMuB,aAAehD,KAAKwB,MAAMC,MAAMhF,MGrK7FiD,OHuKUM,KAAKb,UAAU0D,WACbZ,MAAOjC,KAAKwB,MAAMC,MGtK9BuB,aHuKYd,IAAKlC,KAAKwB,MAAMC,MGrK5BuB,cHuKUhD,KGtKVoC,mBAEA,MHwKQ,KGtKR,IHuKUC,EGtKVK,iBHuKU1C,KAAKwB,MAAMC,MAAMsB,eAAiB/C,KAAKwB,MAAMC,MAAMuB,aGtK7D,EHuKUhD,KAAKb,UAAU0D,WACbZ,MAAOjC,KAAKwB,MAAMC,MGtK9BsB,eHuKYb,IAAKlC,KAAKwB,MAAMC,MGrK5BsB,gBHuKU/C,KGtKVoC,mBAEA,MHwKQ,KGtKR,IHuKUC,EGrKVK,iBHuKc1C,KAAKwB,MAAMC,MAAMsB,iBAAmB/C,KAAKwB,MAAMC,MAAMuB,cACvDhD,KAAKb,UAAUgB,SGtK3B,IHuKYH,KAAKb,UAAU6C,cACbC,MGtKd,EHuKcC,IGrKd,IHuKYlC,KAAKwB,MAAMC,MAAMsB,eAAiB/C,KAAKb,UAAU0D,UGtK7DZ,MHuKYjC,KAAKwB,MAAMC,MAAMuB,aAAehD,KAAKb,UAAU0D,UGrK3DZ,OHuKYjC,KAAKb,UGrKjB2D,YHuKU9C,KGrKVoC,sBHyKIX,MAAO,SAAeY,KACtBY,SAAU,SAAkBZ,GAE1B,IAAIA,EAAEa,QAAN,CAIA,GAAIC,KAA8BC,SAASC,aACvCC,EGjKV,mBHiK6BC,iBAEnBJ,GAAQG,KACVjB,EGlKRK,iBHmKQL,EAAEpD,KAAOoD,EGlKjB1D,IHmKQqB,KAAKwD,UGlKbnB,MHqKImB,UAAW,SAAmBnB,GACxBA,EAAEK,gBAAgBL,EGjK5BK,iBHkKU1C,KAAKb,UAAUsC,MAAMY,EAAEpD,QACzBe,KAAKZ,gBGjKb,GHmKMY,KGjKNoC,qBHmKIqB,MAAO,SAAepB,GACpBrC,KGhKNoC,oBHiKMpC,KAAKZ,gBGhKX,GHkKIsE,IAAK,SAAarB,GAEhB,GADAA,EG9JNK,iBH+JU1C,KAAKwB,MAAMC,MAAMsB,iBAAmB/C,KAAKwB,MAAMC,MAAMuB,aG9J/D,CHmKQ,IACEI,SAASO,YG9JnB,QH+JU,MAAO7B,IACT9B,KAAKb,UG9Jb2D,YH+JQ9C,KG9JRoC,sBHiKIwB,KAAM,SAAcvB,KACpBwB,MAAO,SAAexB,GACpBA,EG3JNK,gBH4JM,IAAIoB,GAAYzB,EAAE0B,cAAcC,QG3JtC,QAFAC,GAAA,EH+JUC,GAAqB,EACrBC,EAAkB9C,MAEtB,KACE,IAAK,GAA+C+C,GAA3CC,EAAaP,EAAUpC,OAAOC,cAAuBsC,GAA8BG,EAASC,EAAWzC,QAAQC,MAAOoC,GAA6B,EAAM,CGhK1K,GAAAvD,GAAA0D,EAAA3H,KHmKUuD,MAAKb,UAAUsC,MGlKzBf,IHoKQ,MAAOoB,GACPoC,GAAqB,EACrBC,EAAkBrC,EAClB,QACA,KACOmC,GAA8BI,EAAWtC,QAC5CsC,EAAWtC,SAEb,QACA,GAAImC,EACF,KAAMC,IAKZnE,KGjLNoC,qBHmLIA,kBAAmB,WACM,OAAnBpC,KAAKb,YAGLa,KAAKwB,MAAMC,MAAMhF,QAAUuD,KAAKb,UAAUqD,aAC5CxC,KAAKwB,MAAMC,MAAMhF,MAAQuD,KAAKb,UGhLtCqD,WHiLQxC,KAAKmC,MAAM,QAASnC,KAAKwB,MAAMC,MAAMhF,MAAOuD,KAAKb,UGhLzDmF,gBHkLMtE,KAAKwB,MAAMC,MAAMsB,eAAiB/C,KAAKb,UAAU0D,UGhLvDZ,MHiLMjC,KAAKwB,MAAMC,MAAMuB,aAAehD,KAAKb,UAAU0D,UGhLrDX,MHkLIqC,QAAS,SAAiBlC,KAC1BmC,QAAS,WACP,MAAuB,QAAnBxE,KAAKb,WACFa,KAAKb,UAAUqD,aAAexC,KAAKb,UG7KhDsF,YH+KIC,SAAU,SAAkBrC,GACtBrC,KAAKwE,YACPxE,KAAKwB,MAAMC,MAAMhF,MG5KzB,GH6KQuD,KAAKb,UAAU6C,cACbC,MG5KV,EH6KUC,IG3KV,IH6KQlC,KAAKmC,MAAM,QAAS,GG5K5B,MH+KIQ,mBAAoB,WAClB3C,KAAKb,UAAU0D,WACbZ,MAAOjC,KAAKwB,MAAMC,MG3K1BsB,eH4KQb,IAAKlC,KAAKwB,MAAMC,MG1KxBuB,eH6KI2B,QAAS,SAAiBtC,GACpBrC,KG1KVwE,WAAAxE,KAAAwB,MAAAC,MAAAsB,iBAAA/C,KAAAwB,MAAAC,MAAAuB,cH2KQhD,KAAKb,UAAU6C,cACbC,MGzKV,EH0KUC,IGxKV,IH0KQlC,KAAKwB,MAAMC,MAAMsB,eAAiB/C,KAAKb,UAAU0D,UGzKzDZ,MH0KQjC,KAAKwB,MAAMC,MAAMuB,aAAehD,KAAKb,UAAU0D,UGzKvDZ,MH0KQjC,KAAKd,WAAac,KAAKb,UAAU0D,UGzKzCZ,MH0KQjC,KGzKRoC,qBH2KQpC,KGxKR2C,yBHiLMiC,GACA,SAAUzI,EAAQD,GI5fxBC,EAAAD,SAAgBmC,OAAA,WAAmB,GAAAwG,GAAA7E,KAAa8E,EAAAD,EAAAE,eAA0BC,EAAAH,EAAAI,MAAAD,IAAAF,CAC1E,OAAAE,GAAA,SACAE,IAAA,QACAC,OACAvF,SAAA,OAAAiF,EAAA1F,WAAA0F,EAAAjF,UAEAwF,UACA3I,MAAAoI,EAAApI,OAEA4I,IACAC,QAAA,SAAAC,GACAV,EAAApC,QAAA+C,UAAA,KAEAC,SAAA,SAAAF,GACAV,EAAA5B,SAAAuC,UAAA,KAEAE,MAAA,SAAAH,GACAV,EAAApB,MAAA+B,UAAA,KAEAhC,UAAA,SAAA+B,GACAV,EAAArB,UAAAgC,UAAA,KAEAG,QAAA,SAAAJ,GACAV,EAAAF,QAAAa,UAAA,KAEAI,MAAA,SAAAL,GACAA,EAAA7C,iBACAmC,EAAAN,QAAAiB,UAAA,KAEAd,SAAA,SAAAa,GACAV,EAAAH,SAAAc,UAAA,KAEA9B,IAAA,SAAA6B,GACAV,EAAAnB,IAAA8B,UAAA,KAEA5B,KAAA,SAAA2B,GACAV,EAAAjB,KAAA4B,UAAA,KAEA3B,MAAA,SAAA0B,GACAV,EAAAhB,MAAA2B,UAAA,SAIClH,qBJkgBKuH,GACA,SAAU1J,EAAQ0C,EAAqB9C,GAE7C,YK/iBA8C,GAAA,EAAe,WAWb,QAASiH,GAAYzD,GACnB,GAAInE,GAAkB,UAAXmE,EAAEnE,KAAmB,UAAY,WACxC6H,EAAQ,GAAIC,aAAY9H,GAC1B+H,SAAS,EACTC,YAAY,GAEdH,GAAMI,aAAc,EACpB9D,EAAE+D,OAAOC,cAAcN,GAGzB,QAASO,GAAejE,GACjBA,EAAE8D,cACLzJ,EAAE6J,oBAAoB,QAAST,GAAa,GAC5CpJ,EAAE6J,oBAAoB,OAAQT,GAAa,GAC3CpJ,EAAE6J,oBAAoB,UAAWD,GAAgB,GACjD5J,EAAE6J,oBAAoB,WAAYD,GAAgB,IAEpDE,WAAW,WACT9J,EAAE6J,oBAAoB,UAAWD,GAAgB,GACjD5J,EAAE6J,oBAAoB,WAAYD,GAAgB,KA7BtD,GAAIG,GAAIC,OACNhK,EAAI+J,EAAErD,QAEY/B,UAAhBoF,EAAEE,YACJjK,EAAEkK,iBAAiB,QAASd,GAAa,GACzCpJ,EAAEkK,iBAAiB,OAAQd,GAAa,GACxCpJ,EAAEkK,iBAAiB,UAAWN,GAAgB,GAC9C5J,EAAEkK,iBAAiB,WAAYN,GAAgB,ML+kB7CO,GACA,SAAU1K,EAAQD,EAASH,GAEjC,YMzlBA,SAAA+K,GAAAC,EAAAC,GACA,GAAAA,EAEA,OADA3H,GAAAvC,OAAA2B,KAAAuI,GACA5K,EAAA,EAAAC,EAAAgD,EAAAK,OAAqCtD,EAAAC,EAAQD,IAC7C2K,EAAA1H,EAAAjD,IAAA4K,EAAA3H,EAAAjD,GAGA,OAAA2K,GAGA,QAAAnD,GAAAqD,GACA,MAAAH,MAAkBG,GASlB,QAAAC,GAAA1G,GACA,GAAA2G,GAAAvD,EAAAwD,EACA,IAAA5G,EAEA,OADA6G,GAAAvK,OAAA2B,KAAA+B,GACApE,EAAA,EAAAC,EAAAgL,EAAA3H,OAAqCtD,EAAAC,EAAQD,IAAA,CAC7C,GAAAsE,GAAA2G,EAAAjL,EACA,OAAAoE,EAAAE,SACAyG,GAAAzG,GAGAyG,EAAAzG,GAAAF,EAAAE,GAIA,MAAAyG,GAkCA,QAAAG,GAAAC,EAAA/G,EAAAb,EAAA6H,GACA,MAAAxH,gBAAAsH,IAKAtH,KAAAL,mBAAA8H,EAEAzH,KAAAQ,oBAAA4G,EAEApH,KAAAuH,SAEAvH,KAAAO,WAEAP,KAAAN,OAAA,EAEAM,KAAA0H,mBAAA,KAEA1H,KAAA2H,kBAAA,KAEA3H,KAAA4H,oBAEA5H,KAAAwH,oBAAA,MAEAxH,MAAA6H,UAtBA,GAAAP,GAAAC,EAAA/G,EAAAb,GAmHA,QAAAmI,GAAA1J,GACA,KAAA4B,eAAA8H,IAAqC,UAAAA,GAAA1J,EAUrC,IATAA,EAAA0I,GACAtG,iBAAA,KACAD,QAAA,KACAiH,iBAAA,EACA7H,gBAAA8H,EACA5E,WAAgBZ,MAAA,EAAAC,IAAA,GAChBzF,MAAA,IACG2B,GAEH,MAAAA,EAAAmC,QACA,SAAAwH,OAAA,yCAGA,oBAAA3J,GAAAuB,iBAAAvB,EAAAuB,gBAAAD,OAAA,EACA,SAAAqI,OAAA,8EAGA/H,MAAAL,gBAAAvB,EAAAuB,gBACAK,KAAAQ,iBAAA0G,EAAA9I,EAAAoC,kBACAR,KAAAgI,WAAA5J,EAAAmC,SACA9D,MAAA2B,EAAA3B,MACAoG,UAAAzE,EAAAyE,UACA2E,gBAAApJ,EAAAoJ,kBA5KA,GAAAS,GAAA,KAEAC,EAAA,OACAC,EAAA,aACAC,EAAA,eAEAX,EAAA,IACAL,GACArG,KACAN,SAAA,SAAAC,GAA8B,MAAA0H,GAAAzH,KAAAD,KAE9B2H,GACA5H,SAAA,SAAAC,GAA8B,MAAAwH,GAAAvH,KAAAD,KAE9BJ,GACAG,SAAA,SAAAC,GAA8B,MAAAyH,GAAAxH,KAAAD,KAE9BE,GACAH,SAAA,SAAAC,GAA8B,MAAAyH,GAAAxH,KAAAD,IAC9BG,UAAA,SAAAH,GAA+B,MAAAA,GAAAI,gBAE/BE,KACAP,SAAA,SAAAC,GAA8B,MAAA0H,GAAAzH,KAAAD,IAC9BG,UAAA,SAAAH,GAA+B,MAAAA,GAAAI,gBAmC/BwG,GAAA/J,UAAAsK,OAAA,WAKA,OAJAS,GAAAtI,KAAAuH,OAAAgB,MAAA,IACAC,EAAA,EACAjI,KAEAnE,EAAA,EAAAC,EAAAiM,EAAA5I,OAAyCtD,EAAAC,EAAOD,IAAA,CAChD,GAAAsE,GAAA4H,EAAAlM,EACA,IAAAsE,IAAAuH,EAAA,CACA,GAAA7L,IAAAC,EAAA,EACA,SAAA0L,OAAA,sCAAAE,EAEAvH,GAAA4H,IAAAlM,OAEAsE,KAAAV,MAAAQ,mBACA,OAAAR,KAAA0H,qBACA1H,KAAA0H,mBAAAc,GAEAxI,KAAA2H,kBAAAa,EACAxI,KAAA4H,iBAAAY,IAAA,EAGAjI,GAAAkI,KAAA/H,GACA8H,IAGA,UAAAxI,KAAA0H,mBACA,SAAAK,OACA,uBAAA/H,KAAAuH,OAAA,8CAIAvH,MAAAO,UACAP,KAAAN,OAAAa,EAAAb,QAOA4H,EAAA/J,UAAAmL,YAAA,SAAAjM,GAIA,OAHAkM,GAAA,GAAAC,OAAA5I,KAAAN,QACAmJ,EAAA,EAEAzM,EAAA,EAAAC,EAAA2D,KAAAN,OAAkCtD,EAAAC,EAAQD,IAC1C,GAAA4D,KAAA8I,gBAAA1M,GAAA,CACA,GAAA4D,KAAAwH,iBACA/K,EAAAiD,QAAAmJ,IACA7I,KAAA+I,eAAAtM,EAAAoM,GAAAzM,GACA,KAEAuM,GAAAvM,GAAAK,EAAAiD,OAAAmJ,GAAA7I,KAAA+I,eAAAtM,EAAAoM,GAAAzM,GACA4D,KAAAa,UAAApE,EAAAoM,GAAAzM,GACA4D,KAAAL,gBACAkJ,QAGAF,GAAAvM,GAAA4D,KAAAO,QAAAnE,GAGAK,EAAAiD,OAAAmJ,GAAApM,EAAAoM,KAAA7I,KAAAO,QAAAnE,IACAyM,GAKA,OAAAF,IAOArB,EAAA/J,UAAAuL,gBAAA,SAAAE,GACA,QAAAhJ,KAAA4H,iBAAAoB,IAQA1B,EAAA/J,UAAAwL,eAAA,SAAArI,EAAAsI,GACA,MAAAhJ,MAAAQ,iBAAAR,KAAAO,QAAAyI,IAAAvI,SAAAC,IAGA4G,EAAA/J,UAAAsD,UAAA,SAAAH,EAAAsI,GACA,GAAAC,GAAAjJ,KAAAQ,iBAAAR,KAAAO,QAAAyI,GACA,yBAAAC,GAAApI,UAAAoI,EAAApI,UAAAH,MAuCAoH,EAAAvK,UAAAkE,MAAA,SAAAf,GAEA,GAAAV,KAAA6C,UAAAZ,QAAAjC,KAAA6C,UAAAX,KACAlC,KAAA6C,UAAAZ,QAAAjC,KAAAO,QAAAb,OACA,QAGA,IAAAwJ,GAAAtF,EAAA5D,KAAA6C,WACAsG,EAAAnJ,KAAAwC,WAEA4G,EAAApJ,KAAA6C,UAAAZ,KASA,IALAmH,EAAApJ,KAAAO,QAAAmH,qBACA0B,EAAApJ,KAAAO,QAAAmH,oBAIA1H,KAAAO,QAAAuI,gBAAAM,GAAA,CACA,IAAApJ,KAAAO,QAAAwI,eAAArI,EAAA0I,GACA,QAEApJ,MAAAvD,MAAA2M,GAAApJ,KAAAO,QAAAM,UAAAH,EAAA0I,GAMA,IADA,GAAAlH,GAAAlC,KAAA6C,UAAAX,IAAA,EACAA,EAAAkH,GACApJ,KAAAO,QAAAuI,gBAAA5G,KACAlC,KAAAvD,MAAAyF,GAAAlC,KAAAL,iBAEAuC,GAOA,KAHAlC,KAAA6C,UAAAZ,MAAAjC,KAAA6C,UAAAX,IAAAkH,EAAA,EAGApJ,KAAAO,QAAAb,OAAAM,KAAA6C,UAAAZ,QACAjC,KAAAO,QAAAuI,gBAAA9I,KAAA6C,UAAAZ,QACAjC,KAAA6C,UAAAZ,QACAjC,KAAA6C,UAAAX,KAiBA,OAbA,OAAAlC,KAAAqJ,gBAEArJ,KAAAsJ,SAAAC,OAAAvJ,KAAAqJ,cAAArJ,KAAAsJ,SAAA5J,OAAAM,KAAAqJ,eACArJ,KAAAqJ,cAAA,OAEA,UAAArJ,KAAAwJ,SACAN,EAAAjH,QAAAiH,EAAAhH,KACA,OAAAlC,KAAAyJ,gBAAAP,EAAAjH,QAAAjC,KAAAyJ,eAAAxH,QACAjC,KAAAsJ,SAAAb,MAAwBhM,MAAA0M,EAAAtG,UAAAqG,EAAAQ,OAAA1J,KAAAwJ,UAExBxJ,KAAAwJ,QAAA,QACAxJ,KAAAyJ,eAAA7F,EAAA5D,KAAA6C,YAEA,GASAiF,EAAAvK,UAAAuF,UAAA,WAEA,OAAA9C,KAAA6C,UAAAZ,OAAA,IAAAjC,KAAA6C,UAAAX,IACA,QAGA,IAAAgH,GAAAtF,EAAA5D,KAAA6C,WACAsG,EAAAnJ,KAAAwC,UAGA,IAAAxC,KAAA6C,UAAAZ,QAAAjC,KAAA6C,UAAAX,IACAlC,KAAAO,QAAAuI,gBAAA9I,KAAA6C,UAAAZ,MAAA,KACAjC,KAAAvD,MAAAuD,KAAA6C,UAAAZ,MAAA,GAAAjC,KAAAL,iBAEAK,KAAA6C,UAAAZ,QACAjC,KAAA6C,UAAAX,UAGA,CAEA,IADA,GAAAA,GAAAlC,KAAA6C,UAAAX,IAAA,EACAA,GAAAlC,KAAA6C,UAAAZ,OACAjC,KAAAO,QAAAuI,gBAAA5G,KACAlC,KAAAvD,MAAAyF,GAAAlC,KAAAL,iBAEAuC,GAEAlC,MAAA6C,UAAAX,IAAAlC,KAAA6C,UAAAZ,MAgBA,MAZA,OAAAjC,KAAAqJ,eAEArJ,KAAAsJ,SAAAC,OAAAvJ,KAAAqJ,cAAArJ,KAAAsJ,SAAA5J,OAAAM,KAAAqJ,gBAEA,cAAArJ,KAAAwJ,SACAN,EAAAjH,QAAAiH,EAAAhH,KACA,OAAAlC,KAAAyJ,gBAAAP,EAAAjH,QAAAjC,KAAAyJ,eAAAxH,QACAjC,KAAAsJ,SAAAb,MAAwBhM,MAAA0M,EAAAtG,UAAAqG,EAAAQ,OAAA1J,KAAAwJ,UAExBxJ,KAAAwJ,QAAA,YACAxJ,KAAAyJ,eAAA7F,EAAA5D,KAAA6C,YAEA,GAWAiF,EAAAvK,UAAAsG,MAAA,SAAApC,GAGA,GAAAkI,IACAlN,MAAAuD,KAAAvD,MAAAmN,QACA/G,UAAAe,EAAA5D,KAAA6C,WACA2G,QAAAxJ,KAAAwJ,QACAF,SAAAtJ,KAAAsJ,SAAAM,QACAP,cAAArJ,KAAAqJ,cACAI,eAAA7F,EAAA5D,KAAAyJ,gBAMA,IAAAzJ,KAAA6C,UAAAZ,MAAAjC,KAAAO,QAAAmH,mBAAA,CACA,OAAAtL,GAAA,EAAAC,EAAA2D,KAAAO,QAAAmH,mBAAA1H,KAAA6C,UAAAZ,MAA+E7F,EAAAC,EAAOD,IACtF,GAAAqF,EAAAoI,OAAAzN,KAAA4D,KAAAO,gBAAAnE,GACA,QAMAqF,KAAAqI,UAAA9J,KAAAO,QAAAmH,mBAAA1H,KAAA6C,UAAAZ,OACAjC,KAAA6C,UAAAZ,MAAAjC,KAAAO,QAAAmH,mBAGA,IAAAtL,EAAA,EAAAC,EAAAoF,EAAA/B,OACAtD,EAAAC,GAAA2D,KAAA6C,UAAAZ,OAAAjC,KAAAO,QAAAoH,kBACAvL,IAAA,CACA,GAAA2N,GAAA/J,KAAAyB,QAAAoI,OAAAzN,GAIA,KAAA2N,EAAA,CACA,GAAA/J,KAAA6C,UAAAZ,MAAA,GAEA,GAAAuG,GAAAxI,KAAA6C,UAAAZ,MAAA,CACA,KAAAjC,KAAAO,QAAAuI,gBAAAN,IACA/G,EAAAoI,OAAAzN,KAAA4D,KAAAO,gBAAAiI,GACA,SAIA,MADA1B,GAAA9G,KAAA2J,IACA,GAIA,UAKA7B,EAAAvK,UAAAyM,KAAA,WAEA,OAAAhK,KAAAsJ,SAAA5J,QAAA,IAAAM,KAAAqJ,cACA,QAGA,IAAAY,EACA,UAAAjK,KAAAqJ,cAAA,CAEArJ,KAAAqJ,cAAArJ,KAAAsJ,SAAA5J,OAAA,EACAuK,EAAAjK,KAAAsJ,SAAAtJ,KAAAqJ,cAGA,IAAA5M,GAAAuD,KAAAwC,UACAyH,GAAAxN,WACAwN,EAAApH,UAAAZ,QAAAjC,KAAA6C,UAAAZ,OACAgI,EAAApH,UAAAX,MAAAlC,KAAA6C,UAAAX,KACAlC,KAAAsJ,SAAAb,MAA0BhM,QAAAoG,UAAAe,EAAA5D,KAAA6C,WAAA6G,OAAA1J,KAAAwJ,QAAAU,WAAA,QAI1BD,GAAAjK,KAAAsJ,WAAAtJ,KAAAqJ,cAMA,OAHArJ,MAAAvD,MAAAwN,EAAAxN,MAAA8L,MAAA,IACAvI,KAAA6C,UAAAoH,EAAApH,UACA7C,KAAAwJ,QAAAS,EAAAP,QACA,GAGA5B,EAAAvK,UAAA4M,KAAA,WACA,OAAAnK,KAAAsJ,SAAA5J,QAAA,MAAAM,KAAAqJ,cACA,QAEA,IAAAY,GAAAjK,KAAAsJ,WAAAtJ,KAAAqJ,cAYA,OAVArJ,MAAAqJ,gBAAArJ,KAAAsJ,SAAA5J,OAAA,IACAM,KAAAqJ,cAAA,KAEAY,EAAAC,WACAlK,KAAAsJ,SAAAc,OAGApK,KAAAvD,MAAAwN,EAAAxN,MAAA8L,MAAA,IACAvI,KAAA6C,UAAAoH,EAAApH,UACA7C,KAAAwJ,QAAAS,EAAAP,QACA,GAKA5B,EAAAvK,UAAAyK,WAAA,SAAAzH,EAAAnC,GACAA,EAAA0I,GACAjE,WAAgBZ,MAAA,EAAAC,IAAA,GAChBzF,MAAA,IACG2B,GACH4B,KAAAO,QAAA,GAAA+G,GAAA/G,EAAAP,KAAAQ,iBAAAR,KAAAL,gBAAAvB,EAAAoJ,iBACAxH,KAAAG,SAAA/B,EAAA3B,OACAuD,KAAAyE,WAAAzE,KAAAO,QAAAmI,gBAAA2B,KAAA,IACArK,KAAA6C,UAAAzE,EAAAyE,UACA7C,KAAAsK,iBAGAxC,EAAAvK,UAAAyE,aAAA,SAAAa,GAEA,GADA7C,KAAA6C,UAAAe,EAAAf,GACA7C,KAAA6C,UAAAZ,QAAAjC,KAAA6C,UAAAX,IAAA,CACA,GAAAlC,KAAA6C,UAAAZ,MAAAjC,KAAAO,QAAAmH,mBAEA,MADA1H,MAAA6C,UAAAZ,MAAAjC,KAAA6C,UAAAX,IAAAlC,KAAAO,QAAAmH,oBACA,CAKA,KADA,GAAAsB,GAAAhJ,KAAA6C,UAAAZ,MACA+G,GAAAhJ,KAAAO,QAAAmH,oBAAA,CACA,GAAA1H,KAAAO,QAAAuI,gBAAAE,EAAA,IACAhJ,KAAAvD,MAAAuM,EAAA,KAAAhJ,KAAAL,iBACAqJ,IAAAhJ,KAAAO,QAAAmH,mBAAA,CACA1H,KAAA6C,UAAAZ,MAAAjC,KAAA6C,UAAAX,IAAA8G,CACA,OAEAA,IAEA,SAEA,UAGAlB,EAAAvK,UAAA4C,SAAA,SAAA1D,GACA,MAAAA,IACAA,EAAA,IAEAuD,KAAAvD,MAAAuD,KAAAO,QAAAmI,YAAAjM,EAAA8L,MAAA,MAGAT,EAAAvK,UAAAiF,SAAA,WACA,MAAAxC,MAAAvD,MAAA4N,KAAA,KAGAvC,EAAAvK,UAAA+G,YAAA,WAEA,OADAiG,MACAnO,EAAA,EAAiBA,EAAA4D,KAAAvD,MAAAiD,OAAuBtD,IACxC4D,KAAAO,QAAAqH,iBAAAxL,MAAA,GACAmO,EAAA9B,KAAAzI,KAAAvD,MAAAL,GAGA,OAAAmO,GAAAF,KAAA,KAGAvC,EAAAvK,UAAA+M,cAAA,WACAtK,KAAAsJ,YACAtJ,KAAAqJ,cAAA,KACArJ,KAAAwJ,QAAA,KACAxJ,KAAAyJ,eAAA7F,EAAA5D,KAAA6C,YAGAiF,EAAAR,UAEAnL,EAAAD,QAAA4L,GNimBM0C,GACA,SAAUrO,EAAQD,EAASH,GOtmCjC,GAAA0O,GAAA1O,EAAA,IAEAA,EAAA,IAEAA,EAAA,IAEA,KAEA,KAGAI,GAAAD,QAAAuO,EAAAvO","file":"component.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 91);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 48:\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 60:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core__ = __webpack_require__(89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inputmask_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__ = __webpack_require__(62);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n //Firefox Polyfill for focus events\n__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__[\"a\" /* default */])();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = {\n\n  name: 'MaskedInput',\n\n  data: function data() {\n    return {\n      marginLeft: 0,\n      mask_core: null,\n      updateAfterAll: false\n    };\n  },\n\n  props: {\n    value: {\n      type: String\n    },\n    mask: {\n      type: String,\n      required: true,\n      validator: function validator(value) {\n        return !!(value && value.length >= 1);\n      }\n    },\n    placeholderChar: {\n      type: String,\n      default: '_',\n      validator: function validator(value) {\n        return !!(value && value.length === 1);\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  watch: {\n    mask: function mask(newMask) {\n      this.initMask();\n    },\n    value: function value(newValue) {\n      if (this.mask_core) this.mask_core.setValue(newValue); //For multiple inputs support\n    }\n  },\n\n  mounted: function mounted() {\n    this.initMask();\n  },\n\n\n  methods: {\n    initMask: function initMask() {\n      try {\n\n        this.mask_core = new __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default.a({\n          pattern: this.mask,\n          value: '',\n          placeholderChar: this.placeholderChar,\n          formatCharacters: {\n            'a': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            'A': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '*': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            '#': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '+': {\n              validate: function validate(char) {\n                return true;\n              }\n            }\n          }\n        });\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.$refs.input.value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var char = _step.value;\n\n            this.mask_core.input(char);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        if (this.$refs.input.value === '') {\n          this.$emit('input', '', '');\n        } else {\n          this.updateToCoreState();\n        }\n      } catch (e) {\n        console.error(e);\n        this.mask_core = null;\n        this.$refs.input.value = 'Error, see console';\n        this.$emit('input', this.$refs.input.value, '');\n      }\n    },\n    getValue: function getValue() {\n      if (this.mask_core === null) return '';\n      return this.mask_core.getValue();\n    },\n    keyDown: function keyDown(e) {\n      //Always\n      if (this.mask_core === null) {\n        e.preventDefault();\n        return;\n      }\n      this.setNativeSelection();\n\n      switch (e.keyCode) {\n\n        //backspace\n        case 8:\n          e.preventDefault();\n          if (this.mask_core.selection.start > this.marginLeft || this.mask_core.selection.start != this.mask_core.selection.end) {\n            this.mask_core.backspace();\n            this.updateToCoreState();\n          }\n          break;\n\n        //left arrow\n        case 37:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd = this.$refs.input.selectionStart--;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //right arrow\n        case 39:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd++;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //end\n        case 35:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //home\n        case 36:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0;\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //delete\n        case 46:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n            this.mask_core.setValue('');\n            this.mask_core.setSelection({\n              start: 0,\n              end: 0\n            });\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\n          } else {\n            this.mask_core.backspace();\n          }\n          this.updateToCoreState();\n          break;\n      }\n    },\n    input: function input(e) {},\n    keyPress: function keyPress(e) {\n      //works only on Desktop\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\n      /*\n       IE & FF are not trigger textInput event, so we have to force it\n      */\n      var isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      var isFirefox = typeof InstallTrigger !== 'undefined';\n\n      if (isIE || isFirefox) {\n        e.preventDefault();\n        e.data = e.key;\n        this.textInput(e);\n      }\n    },\n    textInput: function textInput(e) {\n      if (e.preventDefault) e.preventDefault();\n      if (this.mask_core.input(e.data)) {\n        this.updateAfterAll = true;\n      }\n      this.updateToCoreState();\n    },\n    keyUp: function keyUp(e) {\n      this.updateToCoreState();\n      this.updateAfterAll = false;\n    },\n    cut: function cut(e) {\n      e.preventDefault();\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\n        /*let text = this.$refs.input.value.slice(\n          this.$refs.input.selectionStart,\n          this.$refs.input.selectionEnd\n        )*/\n        try {\n          document.execCommand('copy');\n        } catch (err) {}\n        this.mask_core.backspace();\n        this.updateToCoreState();\n      }\n    },\n    copy: function copy(e) {},\n    paste: function paste(e) {\n      e.preventDefault();\n      var pasteText = e.clipboardData.getData('text');\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = pasteText[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var char = _step2.value;\n\n          this.mask_core.input(char);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.updateToCoreState();\n    },\n    updateToCoreState: function updateToCoreState() {\n      if (this.mask_core === null) {\n        return;\n      }\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\n        this.$refs.input.value = this.mask_core.getValue();\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue());\n      }\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\n    },\n    focusin: function focusin(e) {},\n    isEmpty: function isEmpty() {\n      if (this.mask_core === null) return true;\n      return this.mask_core.getValue() === this.mask_core.emptyValue;\n    },\n    focusout: function focusout(e) {\n      if (this.isEmpty()) {\n        this.$refs.input.value = '';\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$emit('input', '', '');\n      }\n    },\n    setNativeSelection: function setNativeSelection() {\n      this.mask_core.selection = {\n        start: this.$refs.input.selectionStart,\n        end: this.$refs.input.selectionEnd\n      };\n    },\n    mouseUp: function mouseUp(e) {\n      if (this.isEmpty() && this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\n        this.marginLeft = this.mask_core.selection.start;\n        this.updateToCoreState();\n      } else {\n        this.setNativeSelection();\n      }\n    }\n  }\n\n};\n\n/***/ }),\n\n/***/ 61:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('input', {\n    ref: \"input\",\n    attrs: {\n      \"disabled\": _vm.mask_core === null || _vm.disabled\n    },\n    domProps: {\n      \"value\": _vm.value\n    },\n    on: {\n      \"keydown\": function($event) {\n        _vm.keyDown(arguments[0])\n      },\n      \"keypress\": function($event) {\n        _vm.keyPress(arguments[0])\n      },\n      \"keyup\": function($event) {\n        _vm.keyUp(arguments[0])\n      },\n      \"textInput\": function($event) {\n        _vm.textInput(arguments[0])\n      },\n      \"mouseup\": function($event) {\n        _vm.mouseUp(arguments[0])\n      },\n      \"focus\": function($event) {\n        $event.preventDefault();\n        _vm.focusin(arguments[0])\n      },\n      \"focusout\": function($event) {\n        _vm.focusout(arguments[0])\n      },\n      \"cut\": function($event) {\n        _vm.cut(arguments[0])\n      },\n      \"copy\": function($event) {\n        _vm.copy(arguments[0])\n      },\n      \"paste\": function($event) {\n        _vm.paste(arguments[0])\n      }\n    }\n  })\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 62:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\n/* harmony default export */ __webpack_exports__[\"a\"] = function () {\n  var w = window,\n      d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) {\n      // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n};\n\n/***/ }),\n\n/***/ 89:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n/***/ }),\n\n/***/ 91:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(48)(\n  /* script */\n  __webpack_require__(60),\n  /* template */\n  __webpack_require__(61),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// component.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 91);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 50f3647a6bdc53ba6aa4","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 48\n// module chunks = 0 1","<template>\n  <input ref=\"input\"\n    :value=\"value\"\n    @keydown=\"keyDown(arguments[0])\"\n    @keypress=\"keyPress(arguments[0])\"\n    @keyup=\"keyUp(arguments[0])\"\n    @textInput=\"textInput(arguments[0])\"\n    @mouseup=\"mouseUp(arguments[0])\"\n    @focus.prevent=\"focusin(arguments[0])\"\n    @focusout=\"focusout(arguments[0])\"\n    @cut=\"cut(arguments[0])\"\n    @copy=\"copy(arguments[0])\"\n    @paste=\"paste(arguments[0])\"\n    :disabled=\"mask_core===null || disabled\"\n  />\n</template>\n\n<script>\nimport InputMask from 'inputmask-core'\nimport ffpoly from './ff-polyfill.js' //Firefox Polyfill for focus events\nffpoly()\n\nexport default {\n\n  name: 'MaskedInput',\n\n  data: () => ({\n    marginLeft: 0,\n    mask_core: null,\n    updateAfterAll: false\n  }),\n\n  props: {\n    value: {\n      type: String\n    },\n    mask: {\n      type: String,\n      required: true,\n      validator:  value => !! (value && value.length >= 1)\n    },\n    placeholderChar: {\n      type: String,\n      default: '_',\n      validator:  value => !! (value && value.length === 1)\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  watch: {\n    mask: function(newMask) {\n      this.initMask()\n    },\n    value: function(newValue) {\n      if (this.mask_core) this.mask_core.setValue(newValue) //For multiple inputs support\n    },\n  },\n\n  mounted() {\n    this.initMask()\n  },\n\n  methods: {\n\n    initMask() {\n      try {\n\n        this.mask_core = new InputMask({\n          pattern: this.mask,\n          value: '',\n          placeholderChar: this.placeholderChar,\n          formatCharacters: {\n            'a': {\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char),\n            },\n            'A': {\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char) ,\n              transform: char => char.toUpperCase()\n            },\n            '*': {\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\n            },\n            '#': {\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\n              transform: char => char.toUpperCase()\n            },\n            '+': {\n              validate: char => true,\n            },\n          }\n        })\n\n        for (const char of this.$refs.input.value) {\n          this.mask_core.input(char)\n        }\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        if (this.$refs.input.value === '') {\n          this.$emit('input', '', '')\n        }\n        else {\n          this.updateToCoreState()\n        }\n\n\n      }\n      catch (e) {\n        console.error(e);\n        this.mask_core = null\n        this.$refs.input.value = 'Error, see console'\n        this.$emit('input', this.$refs.input.value, '')\n      }\n    },\n\n    getValue() {\n      if (this.mask_core === null) return '';\n      return this.mask_core.getValue()\n    },\n\n    keyDown(e) { //Always\n      if (this.mask_core === null) {\n        e.preventDefault()\n        return;\n      }\n      this.setNativeSelection()\n\n\n      switch (e.keyCode) {\n\n        //backspace\n        case 8:\n          e.preventDefault()\n          if (\n            this.mask_core.selection.start > this.marginLeft ||\n            this.mask_core.selection.start != this.mask_core.selection.end\n          ) {\n            this.mask_core.backspace()\n            this.updateToCoreState()\n          }\n          break;\n\n        //left arrow\n        case 37:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\n            this.$refs.input.selectionEnd = this.$refs.input.selectionStart--\n\n            this.mask_core.selection = {\n              start: this.$refs.input.selectionStart,\n              end: this.$refs.input.selectionStart\n            }\n            this.updateToCoreState()\n          break;\n\n        //right arrow\n        case 39:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\n            this.$refs.input.selectionEnd++;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          }\n          this.updateToCoreState()\n          break;\n\n        //end\n        case 35:\n          e.preventDefault()\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          }\n          this.updateToCoreState()\n          break;\n\n        //home\n        case 36:\n          e.preventDefault()\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          }\n          this.updateToCoreState()\n          break;\n\n        //delete\n        case 46:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n            this.mask_core.setValue('');\n            this.mask_core.setSelection({\n              start: 0,\n              end: 0\n            })\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\n\n          } else {\n            this.mask_core.backspace()\n          }\n          this.updateToCoreState()\n          break;\n      }\n    },\n\n    input(e) {\n    },\n\n    keyPress(e) { //works only on Desktop\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\n      /*\n       IE & FF are not trigger textInput event, so we have to force it\n      */\n      const isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      const isFirefox = typeof InstallTrigger !== 'undefined';\n\n\n      if (isIE || isFirefox) {\n        e.preventDefault()\n        e.data = e.key\n        this.textInput(e)\n      }\n    },\n\n    textInput(e) {\n      if (e.preventDefault) e.preventDefault()\n      if (this.mask_core.input(e.data)) {\n        this.updateAfterAll = true\n      }\n      this.updateToCoreState()\n    },\n\n    keyUp(e) {\n      this.updateToCoreState()\n      this.updateAfterAll = false\n    },\n\n\n    cut(e) {\n      e.preventDefault();\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\n        /*let text = this.$refs.input.value.slice(\n          this.$refs.input.selectionStart,\n          this.$refs.input.selectionEnd\n        )*/\n        try {\n          document.execCommand('copy')\n        } catch (err) {}\n        this.mask_core.backspace()\n        this.updateToCoreState()\n      }\n    },\n\n    copy(e) {\n    },\n\n    paste(e) {\n      e.preventDefault()\n      const pasteText = e.clipboardData.getData('text')\n      for (const char of pasteText) {\n        this.mask_core.input(char)\n      }\n      this.updateToCoreState()\n    },\n\n    updateToCoreState() {\n      if (this.mask_core === null) {\n        return;\n      }\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\n        this.$refs.input.value = this.mask_core.getValue()\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue())\n      }\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\n    },\n\n    focusin(e) {\n    },\n\n    isEmpty() {\n      if (this.mask_core === null) return true;\n      return this.mask_core.getValue() === this.mask_core.emptyValue\n    },\n\n    focusout(e) {\n      if (this.isEmpty()) {\n        this.$refs.input.value = ''\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        this.$emit('input', '', '')\n      }\n    },\n\n    setNativeSelection() {\n      this.mask_core.selection = {\n        start: this.$refs.input.selectionStart,\n        end: this.$refs.input.selectionEnd\n      }\n    },\n\n    mouseUp(e) {\n      if (this.isEmpty() &&\n        this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\n        this.marginLeft = this.mask_core.selection.start;\n        this.updateToCoreState();\n      }\n      else {\n        this.setNativeSelection();\n      }\n    }\n  }\n\n}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// MaskedInput.vue?51917c2f","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('input', {\n    ref: \"input\",\n    attrs: {\n      \"disabled\": _vm.mask_core === null || _vm.disabled\n    },\n    domProps: {\n      \"value\": _vm.value\n    },\n    on: {\n      \"keydown\": function($event) {\n        _vm.keyDown(arguments[0])\n      },\n      \"keypress\": function($event) {\n        _vm.keyPress(arguments[0])\n      },\n      \"keyup\": function($event) {\n        _vm.keyUp(arguments[0])\n      },\n      \"textInput\": function($event) {\n        _vm.textInput(arguments[0])\n      },\n      \"mouseup\": function($event) {\n        _vm.mouseUp(arguments[0])\n      },\n      \"focus\": function($event) {\n        $event.preventDefault();\n        _vm.focusin(arguments[0])\n      },\n      \"focusout\": function($event) {\n        _vm.focusout(arguments[0])\n      },\n      \"cut\": function($event) {\n        _vm.cut(arguments[0])\n      },\n      \"copy\": function($event) {\n        _vm.copy(arguments[0])\n      },\n      \"paste\": function($event) {\n        _vm.paste(arguments[0])\n      }\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-c02302bc!./~/vue-loader/lib/selector.js?type=template&index=0!./src/MaskedInput.vue\n// module id = 61\n// module chunks = 0 1","//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\nexport default () => {\n  var w = window,\n    d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) { // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ff-polyfill.js","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask-core/lib/index.js\n// module id = 89\n// module chunks = 0 1","var Component = require(\"!./../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!./../node_modules/vue-loader/lib/selector?type=script&index=0!./MaskedInput.vue\"),\n  /* template */\n  require(\"!!./../node_modules/vue-loader/lib/template-compiler?id=data-v-c02302bc!./../node_modules/vue-loader/lib/selector?type=template&index=0!./MaskedInput.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MaskedInput.vue\n// module id = 91\n// module chunks = 0 1"],"sourceRoot":""}