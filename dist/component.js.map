{"version":3,"sources":["webpack:///component.js","webpack:///webpack/bootstrap 93d18b3b1f623dab7bb4?c432","webpack:///./~/vue-loader/lib/component-normalizer.js?d4f3","webpack:///MaskedInput.vue?376a","webpack:///./src/MaskedInput.vue?9a93*","webpack:///./src/ff-polyfill.js?7c2c","webpack:///./~/inputmask-core/lib/index.js?3294","webpack:///./src/MaskedInput.vue?88f9"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","48","rawScriptExports","compiledTemplate","scopeId","cssModules","esModule","scriptExports","type","default","options","render","staticRenderFns","_scopeId","computed","keys","forEach","key","60","__webpack_exports__","__WEBPACK_IMPORTED_MODULE_0_inputmask_core__","__WEBPACK_IMPORTED_MODULE_0_inputmask_core___default","__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__","data","marginLeft","mask_core","updateAfterAll","props","String","mask","required","validator","length","placeholderChar","disabled","Boolean","watch","newMask","this","initMask","newValue","setValue","mounted","methods","a","pattern","formatCharacters","validate","char","test","A","transform","toUpperCase","*","#","+","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","$refs","input","Symbol","iterator","next","done","console","log","err","return","setSelection","start","end","$emit","updateToCoreState","e","error","getValue","keyDown","preventDefault","setNativeSelection","keyCode","selection","backspace","selectionStart","selectionEnd","keyPress","ctrlKey","isIE","document","documentMode","isFirefox","InstallTrigger","textInput","keyUp","cut","execCommand","copy","paste","pasteText","clipboardData","getData","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","getRawValue","focusin","isEmpty","emptyValue","focusout","mouseUp","61","_vm","_h","$createElement","_c","_self","ref","attrs","domProps","on","keydown","$event","arguments","keypress","keyup","mouseup","focus","62","addPolyfill","event","CustomEvent","bubbles","cancelable","c1Generated","target","dispatchEvent","removePolyfill","removeEventListener","setTimeout","w","window","onfocusin","addEventListener","89","extend","dest","src","obj","mergeFormatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","Pattern","source","isRevealingMask","DEFAULT_PLACEHOLDER_CHAR","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","InputMask","Error","setPattern","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","1","sourceChars","split","patternIndex","push","formatValue","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","format","selectionBefore","valueBefore","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","initialState","slice","charAt","substring","valid","undo","historyItem","startUndo","redo","pop","join","_resetHistory","rawValue","91","Component"],"mappings":"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","file":"component.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 91);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 48:\n/***/ (function(module, exports) {\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n\n/***/ 60:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core__ = __webpack_require__(89);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_inputmask_core__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__ = __webpack_require__(62);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n //Firefox Polyfill for focus events\n__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__ff_polyfill_js__[\"a\" /* default */])();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = {\n\n  name: 'MaskedInput',\n\n  data: function data() {\n    return {\n      marginLeft: 0,\n      mask_core: null,\n      updateAfterAll: false\n    };\n  },\n\n  props: {\n    value: {\n      type: String\n    },\n    mask: {\n      type: String,\n      required: true,\n      validator: function validator(value) {\n        return !!(value && value.length >= 1);\n      }\n    },\n    placeholderChar: {\n      type: String,\n      default: '_',\n      validator: function validator(value) {\n        return !!(value && value.length === 1);\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  watch: {\n    mask: function mask(newMask) {\n      this.initMask();\n    },\n    value: function value(newValue) {\n      if (this.mask_core) this.mask_core.setValue(newValue); //For multiple inputs support\n    }\n  },\n\n  mounted: function mounted() {\n    this.initMask();\n  },\n\n\n  methods: {\n    initMask: function initMask() {\n      try {\n\n        this.mask_core = new __WEBPACK_IMPORTED_MODULE_0_inputmask_core___default.a({\n          pattern: this.mask,\n          value: '',\n          placeholderChar: this.placeholderChar,\n          formatCharacters: {\n            'a': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            'A': {\n              validate: function validate(char) {\n                return (/^[A-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '*': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              }\n            },\n            '#': {\n              validate: function validate(char) {\n                return (/^[\\dA-Za-zА-Яа-я]$/.test(char)\n                );\n              },\n              transform: function transform(char) {\n                return char.toUpperCase();\n              }\n            },\n            '+': {\n              validate: function validate(char) {\n                return true;\n              }\n            }\n          }\n        });\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.$refs.input.value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var char = _step.value;\n\n            console.log('');\n            //this.mask_core.input(char)\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        if (this.$refs.input.value === '') {\n          this.$emit('input', '', '');\n        } else {\n          this.updateToCoreState();\n        }\n      } catch (e) {\n        console.error(e);\n        this.mask_core = null;\n        this.$refs.input.value = 'Error, see console';\n        this.$emit('input', this.$refs.input.value, '');\n      }\n    },\n    getValue: function getValue() {\n      if (this.mask_core === null) return '';\n      return this.mask_core.getValue();\n    },\n    keyDown: function keyDown(e) {\n      //Always\n      if (this.mask_core === null) {\n        e.preventDefault();\n        return;\n      }\n      this.setNativeSelection();\n\n      switch (e.keyCode) {\n\n        //backspace\n        case 8:\n          e.preventDefault();\n          if (this.mask_core.selection.start > this.marginLeft || this.mask_core.selection.start != this.mask_core.selection.end) {\n            this.mask_core.backspace();\n            this.updateToCoreState();\n          }\n          break;\n\n        //left arrow\n        case 37:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd = this.$refs.input.selectionStart--;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //right arrow\n        case 39:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) this.$refs.input.selectionEnd++;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //end\n        case 35:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          };\n          this.updateToCoreState();\n          break;\n\n        //home\n        case 36:\n          e.preventDefault();\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0;\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          };\n          this.updateToCoreState();\n          break;\n\n        //delete\n        case 46:\n          e.preventDefault();\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n            this.mask_core.setValue('');\n            this.mask_core.setSelection({\n              start: 0,\n              end: 0\n            });\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\n          } else {\n            this.mask_core.backspace();\n          }\n          this.updateToCoreState();\n          break;\n      }\n    },\n    input: function input(e) {},\n    keyPress: function keyPress(e) {\n      //works only on Desktop\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\n      /*\n       IE & FF are not trigger textInput event, so we have to force it\n      */\n      var isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      var isFirefox = typeof InstallTrigger !== 'undefined';\n\n      if (isIE || isFirefox) {\n        e.preventDefault();\n        e.data = e.key;\n        this.textInput(e);\n      }\n    },\n    textInput: function textInput(e) {\n      if (e.preventDefault) e.preventDefault();\n      if (this.mask_core.input(e.data)) {\n        this.updateAfterAll = true;\n      }\n      this.updateToCoreState();\n    },\n    keyUp: function keyUp(e) {\n      this.updateToCoreState();\n      this.updateAfterAll = false;\n    },\n    cut: function cut(e) {\n      e.preventDefault();\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\n        /*let text = this.$refs.input.value.slice(\n          this.$refs.input.selectionStart,\n          this.$refs.input.selectionEnd\n        )*/\n        try {\n          document.execCommand('copy');\n        } catch (err) {}\n        this.mask_core.backspace();\n        this.updateToCoreState();\n      }\n    },\n    copy: function copy(e) {},\n    paste: function paste(e) {\n      e.preventDefault();\n      var pasteText = e.clipboardData.getData('text');\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = pasteText[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var char = _step2.value;\n\n          this.mask_core.input(char);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.updateToCoreState();\n    },\n    updateToCoreState: function updateToCoreState() {\n      if (this.mask_core === null) {\n        return;\n      }\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\n        this.$refs.input.value = this.mask_core.getValue();\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue());\n      }\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\n    },\n    focusin: function focusin(e) {},\n    isEmpty: function isEmpty() {\n      if (this.mask_core === null) return true;\n      return this.mask_core.getValue() === this.mask_core.emptyValue;\n    },\n    focusout: function focusout(e) {\n      if (this.isEmpty()) {\n        this.$refs.input.value = '';\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$emit('input', '', '');\n      }\n    },\n    setNativeSelection: function setNativeSelection() {\n      this.mask_core.selection = {\n        start: this.$refs.input.selectionStart,\n        end: this.$refs.input.selectionEnd\n      };\n    },\n    mouseUp: function mouseUp(e) {\n      if (this.isEmpty() && this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        });\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\n        this.marginLeft = this.mask_core.selection.start;\n        this.updateToCoreState();\n      } else {\n        this.setNativeSelection();\n      }\n    }\n  }\n\n};\n\n/***/ }),\n\n/***/ 61:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('input', {\n    ref: \"input\",\n    attrs: {\n      \"disabled\": _vm.mask_core === null || _vm.disabled\n    },\n    domProps: {\n      \"value\": _vm.value\n    },\n    on: {\n      \"keydown\": function($event) {\n        _vm.keyDown(arguments[0])\n      },\n      \"keypress\": function($event) {\n        _vm.keyPress(arguments[0])\n      },\n      \"keyup\": function($event) {\n        _vm.keyUp(arguments[0])\n      },\n      \"textInput\": function($event) {\n        _vm.textInput(arguments[0])\n      },\n      \"mouseup\": function($event) {\n        _vm.mouseUp(arguments[0])\n      },\n      \"focus\": function($event) {\n        $event.preventDefault();\n        _vm.focusin(arguments[0])\n      },\n      \"focusout\": function($event) {\n        _vm.focusout(arguments[0])\n      },\n      \"cut\": function($event) {\n        _vm.cut(arguments[0])\n      },\n      \"copy\": function($event) {\n        _vm.copy(arguments[0])\n      },\n      \"paste\": function($event) {\n        _vm.paste(arguments[0])\n      }\n    }\n  })\n},staticRenderFns: []}\n\n/***/ }),\n\n/***/ 62:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\n/* harmony default export */ __webpack_exports__[\"a\"] = function () {\n  var w = window,\n      d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) {\n      // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n};\n\n/***/ }),\n\n/***/ 89:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n/***/ }),\n\n/***/ 91:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(48)(\n  /* script */\n  __webpack_require__(60),\n  /* template */\n  __webpack_require__(61),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ })\n\n/******/ });\n\n\n// WEBPACK FOOTER //\n// component.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 91);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 93d18b3b1f623dab7bb4","module.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  scopeId,\n  cssModules\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  // inject cssModules\n  if (cssModules) {\n    var computed = options.computed || (options.computed = {})\n    Object.keys(cssModules).forEach(function (key) {\n      var module = cssModules[key]\n      computed[key] = function () { return module }\n    })\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 48\n// module chunks = 0 1","<template>\n  <input ref=\"input\"\n    :value=\"value\"\n    @keydown=\"keyDown(arguments[0])\"\n    @keypress=\"keyPress(arguments[0])\"\n    @keyup=\"keyUp(arguments[0])\"\n    @textInput=\"textInput(arguments[0])\"\n    @mouseup=\"mouseUp(arguments[0])\"\n    @focus.prevent=\"focusin(arguments[0])\"\n    @focusout=\"focusout(arguments[0])\"\n    @cut=\"cut(arguments[0])\"\n    @copy=\"copy(arguments[0])\"\n    @paste=\"paste(arguments[0])\"\n    :disabled=\"mask_core===null || disabled\"\n  />\n</template>\n\n<script>\nimport InputMask from 'inputmask-core'\nimport ffpoly from './ff-polyfill.js' //Firefox Polyfill for focus events\nffpoly()\n\nexport default {\n\n  name: 'MaskedInput',\n\n  data: () => ({\n    marginLeft: 0,\n    mask_core: null,\n    updateAfterAll: false\n  }),\n\n  props: {\n    value: {\n      type: String\n    },\n    mask: {\n      type: String,\n      required: true,\n      validator:  value => !! (value && value.length >= 1)\n    },\n    placeholderChar: {\n      type: String,\n      default: '_',\n      validator:  value => !! (value && value.length === 1)\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    }\n  },\n\n  watch: {\n    mask: function(newMask) {\n      this.initMask()\n    },\n    value: function(newValue) {\n      if (this.mask_core) this.mask_core.setValue(newValue) //For multiple inputs support\n    },\n  },\n\n  mounted() {\n    this.initMask()\n  },\n\n  methods: {\n\n    initMask() {\n      try {\n\n        this.mask_core = new InputMask({\n          pattern: this.mask,\n          value: '',\n          placeholderChar: this.placeholderChar,\n          formatCharacters: {\n            'a': {\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char),\n            },\n            'A': {\n              validate: char => /^[A-Za-zА-Яа-я]$/.test(char) ,\n              transform: char => char.toUpperCase()\n            },\n            '*': {\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\n            },\n            '#': {\n              validate: char => /^[\\dA-Za-zА-Яа-я]$/.test(char),\n              transform: char => char.toUpperCase()\n            },\n            '+': {\n              validate: char => true,\n            },\n          }\n        })\n\n        for (const char of this.$refs.input.value) {\n          console.log('');\n          //this.mask_core.input(char)\n        }\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        if (this.$refs.input.value === '') {\n          this.$emit('input', '', '')\n        }\n        else {\n          this.updateToCoreState()\n        }\n\n\n      }\n      catch (e) {\n        console.error(e);\n        this.mask_core = null\n        this.$refs.input.value = 'Error, see console'\n        this.$emit('input', this.$refs.input.value, '')\n      }\n    },\n\n    getValue() {\n      if (this.mask_core === null) return '';\n      return this.mask_core.getValue()\n    },\n\n    keyDown(e) { //Always\n      if (this.mask_core === null) {\n        e.preventDefault()\n        return;\n      }\n      this.setNativeSelection()\n\n\n      switch (e.keyCode) {\n\n        //backspace\n        case 8:\n          e.preventDefault()\n          if (\n            this.mask_core.selection.start > this.marginLeft ||\n            this.mask_core.selection.start != this.mask_core.selection.end\n          ) {\n            this.mask_core.backspace()\n            this.updateToCoreState()\n          }\n          break;\n\n        //left arrow\n        case 37:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\n            this.$refs.input.selectionEnd = this.$refs.input.selectionStart--\n\n            this.mask_core.selection = {\n              start: this.$refs.input.selectionStart,\n              end: this.$refs.input.selectionStart\n            }\n            this.updateToCoreState()\n          break;\n\n        //right arrow\n        case 39:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd)\n            this.$refs.input.selectionEnd++;\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          }\n          this.updateToCoreState()\n          break;\n\n        //end\n        case 35:\n          e.preventDefault()\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = this.$refs.input.value.length\n\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionEnd,\n            end: this.$refs.input.selectionEnd\n          }\n          this.updateToCoreState()\n          break;\n\n        //home\n        case 36:\n          e.preventDefault()\n          this.$refs.input.selectionStart = this.$refs.input.selectionEnd = 0\n          this.mask_core.selection = {\n            start: this.$refs.input.selectionStart,\n            end: this.$refs.input.selectionStart\n          }\n          this.updateToCoreState()\n          break;\n\n        //delete\n        case 46:\n          e.preventDefault()\n\n          if (this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n            this.mask_core.setValue('');\n            this.mask_core.setSelection({\n              start: 0,\n              end: 0\n            })\n            this.$refs.input.selectionStart = this.mask_core.selection.start;\n            this.$refs.input.selectionEnd = this.mask_core.selection.start;\n\n          } else {\n            this.mask_core.backspace()\n          }\n          this.updateToCoreState()\n          break;\n      }\n    },\n\n    input(e) {\n    },\n\n    keyPress(e) { //works only on Desktop\n      if (e.ctrlKey) return; //Fix FF copy/paste issue\n      /*\n       IE & FF are not trigger textInput event, so we have to force it\n      */\n      const isIE = /*@cc_on!@*/false || !!document.documentMode; //by http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      const isFirefox = typeof InstallTrigger !== 'undefined';\n\n\n      if (isIE || isFirefox) {\n        e.preventDefault()\n        e.data = e.key\n        this.textInput(e)\n      }\n    },\n\n    textInput(e) {\n      if (e.preventDefault) e.preventDefault()\n      if (this.mask_core.input(e.data)) {\n        this.updateAfterAll = true\n      }\n      this.updateToCoreState()\n    },\n\n    keyUp(e) {\n      this.updateToCoreState()\n      this.updateAfterAll = false\n    },\n\n\n    cut(e) {\n      e.preventDefault();\n      if (this.$refs.input.selectionStart !== this.$refs.input.selectionEnd) {\n        /*let text = this.$refs.input.value.slice(\n          this.$refs.input.selectionStart,\n          this.$refs.input.selectionEnd\n        )*/\n        try {\n          document.execCommand('copy')\n        } catch (err) {}\n        this.mask_core.backspace()\n        this.updateToCoreState()\n      }\n    },\n\n    copy(e) {\n    },\n\n    paste(e) {\n      e.preventDefault()\n      const pasteText = e.clipboardData.getData('text')\n      for (const char of pasteText) {\n        this.mask_core.input(char)\n      }\n      this.updateToCoreState()\n    },\n\n    updateToCoreState() {\n      if (this.mask_core === null) {\n        return;\n      }\n      if (this.$refs.input.value !== this.mask_core.getValue()) {\n        this.$refs.input.value = this.mask_core.getValue()\n        this.$emit('input', this.$refs.input.value, this.mask_core.getRawValue())\n      }\n      this.$refs.input.selectionStart = this.mask_core.selection.start;\n      this.$refs.input.selectionEnd = this.mask_core.selection.end;\n    },\n\n    focusin(e) {\n    },\n\n    isEmpty() {\n      if (this.mask_core === null) return true;\n      return this.mask_core.getValue() === this.mask_core.emptyValue\n    },\n\n    focusout(e) {\n      if (this.isEmpty()) {\n        this.$refs.input.value = ''\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        this.$emit('input', '', '')\n      }\n    },\n\n    setNativeSelection() {\n      this.mask_core.selection = {\n        start: this.$refs.input.selectionStart,\n        end: this.$refs.input.selectionEnd\n      }\n    },\n\n    mouseUp(e) {\n      if (this.isEmpty() &&\n        this.$refs.input.selectionStart === this.$refs.input.selectionEnd) {\n        this.mask_core.setSelection({\n          start: 0,\n          end: 0\n        })\n        this.$refs.input.selectionStart = this.mask_core.selection.start;\n        this.$refs.input.selectionEnd = this.mask_core.selection.start;\n        this.marginLeft = this.mask_core.selection.start;\n        this.updateToCoreState();\n      }\n      else {\n        this.setNativeSelection();\n      }\n    }\n  }\n\n}\n</script>\n\n\n\n// WEBPACK FOOTER //\n// MaskedInput.vue?6d3c6fc8","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('input', {\n    ref: \"input\",\n    attrs: {\n      \"disabled\": _vm.mask_core === null || _vm.disabled\n    },\n    domProps: {\n      \"value\": _vm.value\n    },\n    on: {\n      \"keydown\": function($event) {\n        _vm.keyDown(arguments[0])\n      },\n      \"keypress\": function($event) {\n        _vm.keyPress(arguments[0])\n      },\n      \"keyup\": function($event) {\n        _vm.keyUp(arguments[0])\n      },\n      \"textInput\": function($event) {\n        _vm.textInput(arguments[0])\n      },\n      \"mouseup\": function($event) {\n        _vm.mouseUp(arguments[0])\n      },\n      \"focus\": function($event) {\n        $event.preventDefault();\n        _vm.focusin(arguments[0])\n      },\n      \"focusout\": function($event) {\n        _vm.focusout(arguments[0])\n      },\n      \"cut\": function($event) {\n        _vm.cut(arguments[0])\n      },\n      \"copy\": function($event) {\n        _vm.copy(arguments[0])\n      },\n      \"paste\": function($event) {\n        _vm.paste(arguments[0])\n      }\n    }\n  })\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler.js?id=data-v-c02302bc!./~/vue-loader/lib/selector.js?type=template&index=0!./src/MaskedInput.vue\n// module id = 61\n// module chunks = 0 1","//https://gist.github.com/nuxodin/9250e56a3ce6c0446efa\nexport default () => {\n  var w = window,\n    d = w.document;\n\n  if (w.onfocusin === undefined) {\n    d.addEventListener('focus', addPolyfill, true);\n    d.addEventListener('blur', addPolyfill, true);\n    d.addEventListener('focusin', removePolyfill, true);\n    d.addEventListener('focusout', removePolyfill, true);\n  }\n\n  function addPolyfill(e) {\n    var type = e.type === 'focus' ? 'focusin' : 'focusout';\n    var event = new CustomEvent(type, {\n      bubbles: true,\n      cancelable: false\n    });\n    event.c1Generated = true;\n    e.target.dispatchEvent(event);\n  }\n\n  function removePolyfill(e) {\n    if (!e.c1Generated) { // focus after focusin, so chrome will the first time trigger tow times focusin\n      d.removeEventListener('focus', addPolyfill, true);\n      d.removeEventListener('blur', addPolyfill, true);\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    }\n    setTimeout(function () {\n      d.removeEventListener('focusin', removePolyfill, true);\n      d.removeEventListener('focusout', removePolyfill, true);\n    });\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ff-polyfill.js","'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inputmask-core/lib/index.js\n// module id = 89\n// module chunks = 0 1","var Component = require(\"!./../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!./../node_modules/vue-loader/lib/selector?type=script&index=0!./MaskedInput.vue\"),\n  /* template */\n  require(\"!!./../node_modules/vue-loader/lib/template-compiler?id=data-v-c02302bc!./../node_modules/vue-loader/lib/selector?type=template&index=0!./MaskedInput.vue\"),\n  /* scopeId */\n  null,\n  /* cssModules */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/MaskedInput.vue\n// module id = 91\n// module chunks = 0 1"],"sourceRoot":""}